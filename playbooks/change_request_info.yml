---
- name: Changes abertas + detalhes
  hosts: localhost
  connection: local
  gather_facts: false
  collections:
    - servicenow.itsm

  vars:
    # Credenciais/instância (use credencial no AAP)
    host: "{{ snow_instance }}"
    username: "{{ snow_username }}"
    password: "{{ snow_password }}"

    # Janelas/limiares
    window_minutes_new: 15   # janela para "novas"
    stale_hours: 24          # sem update >= Xh
    near_breach_minutes: 60  # SLA vence em <= X min


  tasks:
    # 1) Coleta única: todas as changes abertas
    - name: Buscar changes abertas (phase_state=open)
      servicenow.itsm.change_request_info:
        instance:
          host: "{{ snow_instance }}"
          username: "{{ snow_username }}"
          password: "{{ snow_password }}"
        sysparm_query: "active=true^phase_state=open"
        sysparm_display_value: "true"
      register: abertas

    - name: debug da variavel abertas
      debug:
        msg: "{{ abertas.records | map(attribute='number') | list }}"

    # 2) Guardar dados crus e sys_ids para referência futura
    - name: Guardar lista de changes e sys_ids
      set_fact:
        chg_all: "{{ abertas.records | default([]) }}"
        chg_sys_ids: "{{ (abertas.records | map(attribute='sys_id') | list) | default([]) }}"

    # 3.1) Quantidade total de changes abertas
    - name: Contagem total
      debug:
        msg: "Total de changes abertas encontradas: {{ chg_all | length }}"

    # 3.2) Epoch atual (em segundos) — portátil e rápido
    - name: Epoch atual (UTC)
      set_fact:
        now_epoch: "{{ lookup('pipe', 'date -u +%s') | int }}"

    # 4) Inicializa buckets vazios
    - name: Inicializar buckets locais
      set_fact:
        chg_new: []
        chg_stale: []

    # 5) Classificar NOVAS: opened_at dentro da janela (comparando epochs)
    #    Dica: se opened_at estiver vazio, ignora.
    - name: Adicionar em NOVAS quando opened_at <= {{ window_minutes_new }} min atrás
      set_fact:
        chg_new: "{{ chg_new + [ item ] }}"
      loop: "{{ chg_all }}"
      loop_control:
        label: "{{ item.number }}"
      when:
        - item.opened_at is defined
        - item.opened_at | string | length > 0
        - >
          (
            now_epoch
            -
            (lookup('pipe', 'date -u -d \"' ~ item.opened_at ~ '\" +%s') | int)
          ) <= (window_minutes_new * 60)

    # 6) Classificar STALE: sys_updated_on >= {{ stale_hours }} horas atrás
    - name: Adicionar em STALE quando sem atualização há >= {{ stale_hours }}h
      set_fact:
        chg_stale: "{{ chg_stale + [ item ] }}"
      loop: "{{ chg_all }}"
      loop_control:
        label: "{{ item.number }}"
      when:
        - item.sys_updated_on is defined
        - item.sys_updated_on | string | length > 0
        - >
          (
            now_epoch
            -
            (lookup('pipe', 'date -u -d \"' ~ item.sys_updated_on ~ '\" +%s') | int)
          ) >= (stale_hours * 3600)

    # 7) Resumo dos buckets (sem novas chamadas)
    - name: Contagens por bucket (local)
      debug:
        msg:
          - "Novas ({{ window_minutes_new }} min): {{ chg_new | length }}"
          - "Stale (>= {{ stale_hours }}h): {{ chg_stale | length }}"

    - name: Listas simples (números)
      debug:
        msg:
          novas:  "{{ chg_new   | map(attribute='number') | list }}"
          stale:  "{{ chg_stale | map(attribute='number') | list }}"

    # 8) (Opcional) Montar mensagem de texto pronta para o Google Chat
    - name: Montar mensagem (texto)
      set_fact:
        chat_text: |-
          *Changes novas ({{ chg_new | length }})*
          {{ (chg_new | map(attribute='number') | list) | default([]) }}

          *>= {{ stale_hours }}h sem atualização ({{ chg_stale | length }})*
          {{ (chg_stale | map(attribute='number') | list) | default([]) }}

    - name: Pré-visualizar mensagem
      debug:
        var: chat_text

    # 9) Observação sobre SLA:
    #    "Near-breach" e "Violadas" vêm da TABELA task_sla (relacionada à change por task=sys_id).
    #    Isso não está dentro de change_request. Para esses dois buckets,
    #    a forma mais eficiente é UMA consulta em lote na task_sla com taskIN<sys_ids> (apenas 1 chamada),
    #    evitando N chamadas por registro.